[ { "title": "isa", "url": "/posts/isa/", "categories": "ios, objective-c", "tags": "ios, objective-c, runtime", "date": "2020-11-04 07:20:00 +0000", "snippet": "struct objc_class { Class isa; //....}/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object { Class isa OBJC_ISA_AVAILABILITY;};/// A pointer to an instance of a class.typedef struct objc_object *id..." }, { "title": "nil / Nil / NULL / NSNull", "url": "/posts/nil-Nil-NULL-NSNull/", "categories": "ios, objective-c", "tags": "ios, objective-c", "date": "2020-11-04 06:58:00 +0000", "snippet": " Symbol Value Meaning NULL (void *)0 literal null value for C pointers nil (id)0 literal null value for Objective-C objects Nil (Class)0 literal null value for Objective-C classes NSNull ..." }, { "title": "__attribute__", "url": "/posts/__attribute__/", "categories": "ios, objective-c", "tags": "ios, objective-c", "date": "2020-11-03 11:48:00 +0000", "snippet": "__attribute__ 是一个用于在声明时指定一些特性的编译器指令，它可以让我们进行更多的错误检查和高级优化工作。使用这个关键字的语法是 __attribute__ 后面跟两组括号（两个括号可以让它很容易在宏里面使用，特别是有多个属性的时候）。在括号里面是用逗号分隔的属性列表。__attribute__ 指令可以放在函数，变量和类型声明之后。// Return the square of a numberint square(int n) __attribute__((const));// Declare the availability of a particular APIvoi..." }, { "title": "Methods Dispatch", "url": "/posts/Methods-Dispatch/", "categories": "ios, objective-c", "tags": "ios, objective-c, swift", "date": "2020-11-03 08:19:00 +0000", "snippet": "Message Dispatch and the Objective-C RuntimeObjective-C程序的实现就是一系列对象通过方法（消息）来进行交互，使用下面这个语法：[someObject aMethod:withAnArgument];此外，我们也可以使用objc_msgSend这个c方法来进行消息的发送。objc_msgSend(object, @selector(message), withAnArgument);对于SEL对应的IMP指针指向的方法，同样，含有两个隐藏的参数，id和SEL类型，它们的值为当前消息的接受者和当前消息的selector。Objective..." }, { "title": "Method Swizzling", "url": "/posts/Method-Swizzling/", "categories": "ios, objective-c", "tags": "ios, objective-c", "date": "2020-11-02 12:31:00 +0000", "snippet": "Objective-C 中的方法其实是C的一个结构体，类型为Method，它是objc_method结构体的类型别名。struct objc_method { SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;}我们可以使用objc/runtime的 class_getClassMethod方法来获取一个Method。还可对对象的方法进行添加或者替换。//获取类..." }, { "title": "Equality", "url": "/posts/Equality/", "categories": "ios, objective-c", "tags": "ios, objective-c", "date": "2020-11-02 06:35:00 +0000", "snippet": "Equality &amp;amp; Identity在 Objective-C 中，如果我们使用 == 判断两个对象是否相等，那么编译器会使用它们的内存地址作为 Identity 进行比较，这也与 NSObject 的 isEqual: 方法的默认实现相同。两个 NSObject 如果指向了同一个内存地址，那它们就被认为是相同的。@implementation NSObject (Approximate)- (BOOL)isEqual:(id)object { return self == object;}@end但是某些 NSObject 子类重写了 isEqual: 方法，重新定..." }, { "title": "C Storage Classes", "url": "/posts/C-Storage-Classes/", "categories": "ios, objective-c", "tags": "ios, objective-c", "date": "2020-11-01 10:50:00 +0000", "snippet": "在 C 语言中，程序内变量或函数的 作用域（scope） 和 寿命（lifetime） 是由其 存储类（storage class） 确定的。每个变量都具有生存周期，或存储其值的上下文。方法，同变量一样，也存在或可见于一个特殊的范围里，这就决定了哪一部分程序知道且能够访问它们。C中有四种存储类： auto register static externautoauto 是默认的 storage classes，当进入对应的作用域（代码块）中时，声明为 auto 的变量的内存空间会被自动地分配，并且在离开该作用域（代码块）的时候被释放，只有在对应的代码块，或者嵌套的代码块中才能访问..." }, { "title": "bool", "url": "/posts/bool/", "categories": "ios, objective-c", "tags": "ios, objective-c", "date": "2020-11-01 09:33:00 +0000", "snippet": "Objective-C用BOOL来编码真值。它是signed char的typedef，并且用宏YES和NO来相应的表示真和假。布尔值用于条件判断，比如if和while语句，来进行有条件的逻辑或者重复运行。当判断一个条件语句，数值0为“假”，而其他任何数值为“真”。因为NULL和nil被定义为0，所以对于这些不存在的数值的条件语句也被判定为“假”。在Objective-C中，当遇到处理真值的参数，属性和实例变量时，使用类型BOOL。当分配字面值时，使用宏YES和NO。 Name Typedef Header True Value ..." }, { "title": "Associated Objects", "url": "/posts/Associated-Objects/", "categories": "ios, objective-c", "tags": "ios, objective-c", "date": "2020-11-01 07:24:00 +0000", "snippet": "对象关联（或称为关联引用）本来是 Objective-C 2.0 运行时的一个特性，起始于 OS X Snow Leopard 和 iOS 4 。相关参考可以查看 &amp;lt;objc/runtime.h&amp;gt; 中定义的以下三个允许你将任何键值在运行时关联到对象上的函数： objc_setAssociatedObject objc_getAssociatedObject objc_removeAssociatedObjects这允许开发者对已经存在的类在扩展中添加自定义的属性。Associated Key因为是使用唯一的 key 地址来检索关联对象，所以对 key..." }, { "title": "at", "url": "/posts/at/", "categories": "ios, objective-c", "tags": "ios, objective-c", "date": "2020-10-30 09:26:00 +0000", "snippet": "Interface &amp;amp; Implementation使用@interface…@end@implementation…@end来进行类的声明和实现 。类别 Category 类别是声明在类的 {.h, .m} 文件外的单独{.h, .m} 文件中。 类别只能声明方法，声明属性不会创建 _var，也不会创建 getter 和 setter 类别的内容可以被继承。 对于类的同方法，类别会覆盖其实现。MyObject+CategoryName.m@implementation MyObject (CategoryName) - (void)foo { // ..." }, { "title": "#pragma", "url": "/posts/pragma/", "categories": "ios, objective-c", "tags": "ios, objective-c", "date": "2020-10-30 09:26:00 +0000", "snippet": "#pragma 是预处理指令。管理代码 Organizin Code可以使用 #pragma mark - ... 为代码添加分割线。消除警告 Inhibiting Warnings使用 #pragma clang diagnostic push/pop，可以告诉编译器消除某一段代码的警告。// clang诊断push#pragma clang diagnostic push // 忽略undeclared selector的警告#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot; [self p..." } ]
